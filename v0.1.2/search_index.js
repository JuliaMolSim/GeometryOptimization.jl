var documenterSearchIndex = {"docs":
[{"location":"apireference/","page":"API reference","title":"API reference","text":"CurrentModule = GeometryOptimization","category":"page"},{"location":"apireference/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"apireference/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"apireference/","page":"API reference","title":"API reference","text":"Modules = [GeometryOptimization]","category":"page"},{"location":"apireference/#GeometryOptimization.Autoselect","page":"API reference","title":"GeometryOptimization.Autoselect","text":"Use a heuristic to automatically select the minimisation algorithm (Currently OptimCG, but this may change silently)\n\n\n\n\n\n","category":"type"},{"location":"apireference/#GeometryOptimization.GeoOptDefaultCallback","page":"API reference","title":"GeometryOptimization.GeoOptDefaultCallback","text":"Callback producing a convergence table summarising the geometry optimisation convergence. If always_show_header=true the header is shown in each iteration. This is helpful if the calculator produces output as well.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#GeometryOptimization.OptimCG","page":"API reference","title":"GeometryOptimization.OptimCG","text":"Use Optim's ConjugateGradient implementation with some good defaults.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#GeometryOptimization.OptimLBFGS","page":"API reference","title":"GeometryOptimization.OptimLBFGS","text":"Use Optim's LBFGS implementation with some good defaults.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#GeometryOptimization.OptimSD","page":"API reference","title":"GeometryOptimization.OptimSD","text":"Use Optim's GradientDescent (Steepest Descent) implementation with some good defaults.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SciMLBase.OptimizationProblem-Tuple{Any, Any, Any}","page":"API reference","title":"SciMLBase.OptimizationProblem","text":"Optimization.OptimizationProblem(system, calculator geoopt_state; kwargs...)\n\nTurn system, calculator and geoopt_state::GeometryOptimizationState into a SciML-compatible OptimizationProblem. Note that the system is not updated automatically and that internally atomic units are used.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#GeometryOptimization.clamp_atoms-Tuple{Any, Union{Nothing, AbstractVector{<:Integer}}}","page":"API reference","title":"GeometryOptimization.clamp_atoms","text":"clamp_atoms(\n    system,\n    clamped_indexes::Union{Nothing, AbstractVector{<:Integer}}\n) -> AtomsBase.FlexibleSystem{_A, _B, AtomsBase.PeriodicCell{_A1, _B1}} where {_A, _B, _A1, _B1}\n\n\nClamp given atoms in the system. Clamped atoms are fixed and their positions will not be optimized. The atoms to be clamped should be given as a list of indices corresponding to their positions in the system.\n\nwarn: Experimental\nThis is this a very experimental interface and will likely change in the future.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#GeometryOptimization.convert_to_updatable-Tuple{Any}","page":"API reference","title":"GeometryOptimization.convert_to_updatable","text":"convert_to_updatable(system) -> Any\n\n\nConvert the input system to a kind of system we can work with, i.e. one where we have the particles keyword argument for setting new particles and positions.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#GeometryOptimization.minimize_energy!","page":"API reference","title":"GeometryOptimization.minimize_energy!","text":"minimize_energy!(\n    system,\n    calculator;\n    ...\n) -> NamedTuple{(:system, :converged, :energy, :forces, :virial, :state, :stats, :alg, :optimres), <:Tuple{AtomsBase.FlexibleSystem{_A, _B, AtomsBase.PeriodicCell{_A1, _B1}} where {_A, _B, _A1, _B1}, Any, Any, Any, Any, Any, Any, Union{Optim.ConjugateGradient{Float64, Nothing, Optim.var\"#33#35\", LineSearches.InitialHagerZhang{Float64}, LineSearches.BackTracking{Float64, Int64}}, Optim.Fminbox{Optim.ConjugateGradient{Float64, Nothing, Optim.var\"#33#35\", LineSearches.InitialHagerZhang{Float64}, LineSearches.BackTracking{Float64, Int64}}, Float64, Optim.var\"#51#53\"}}, Union{SciMLBase.OptimizationSolution{_A, _B, var\"#s182\", OptimizationBase.OptimizationCache{F, RC, LB, UB, LC, UC, S, O, D, P, C, M}, Optim.ConjugateGradient{Float64, Nothing, Optim.var\"#33#35\", LineSearches.InitialHagerZhang{Float64}, LineSearches.BackTracking{Float64, Int64}}, _C, Optim.MultivariateOptimizationResults{O1, Tx, Tc, Tf, M1, Tls, Tsb}, SciMLBase.OptimizationStats} where {_A, _B, T, N, var\"#s182\"<:AbstractArray{T, N}, F, RC, LB, UB, LC, UC, S, O, D, P, C, M, _C, O1, Tx, Tc, Tf, M1, Tls, Tsb}, SciMLBase.OptimizationSolution{_A, _B, _C, OptimizationBase.OptimizationCache{F, RC, LB, UB, LC, UC, S, O, D, P, C, M}, Optim.Fminbox{Optim.ConjugateGradient{Float64, Nothing, Optim.var\"#33#35\", LineSearches.InitialHagerZhang{Float64}, LineSearches.BackTracking{Float64, Int64}}, Float64, Optim.var\"#51#53\"}} where {_A, _B, _C, F, RC, LB, UB, LC, UC, S, O, D, P, C, M}}}}\nminimize_energy!(\n    system,\n    calculator,\n    solver;\n    kwargs...\n) -> NamedTuple{(:system, :converged, :energy, :forces, :virial, :state, :stats, :alg, :optimres), <:Tuple{AtomsBase.FlexibleSystem{_A, _B, AtomsBase.PeriodicCell{_A1, _B1}} where {_A, _B, _A1, _B1}, Vararg{Any, 8}}}\n\n\nMinimise the energy of a system using the specified calculator. For now only optimises atomic positions. Returns a named tuple including the optimised system as first entry. Under the hood this constructs an Optimization.OptimizationProblem and uses Optimization.jl to solve it using the passed solver.\n\nTypical arguments passed as solver are GeometryOptimization.Autoselect() (the default), GeometryOptimization.OptimLBFGS(), GeometryOptimization.OptimCG(), GeometryOptimization.OptimSD(). These automatically choose some heuristics for setting up the solvers, which we found to work well in practice. Beyond that any other solver compatible with Optimization.jl can also be employed here.\n\nKeyword arguments:\n\nmaxiters: Maximal number of iterations\nmaxtime:  Maximal allowed runtime (in seconds)\ntol_energy: Tolerance in the energy to stop the minimisation (all tol_* need to be satisfied)\ntol_forces:  Tolerance in the force  to stop the minimisation (all tol_* need to be satisfied)\ntol_virial: Tolerance in the virial to stop the minimisation (all tol_* need to be satisfied)\nmaxstep: Maximal step size (in AU or length units) to be taken in a single optimisation step (not supported for all solvers)\nverbosity: Printing level. The idea is that 0 is silent, 1 displays the optimisation progress and ≥ 2 starts displaying things from the calculator as well (e.g SCF iterations).\ncallback: A custom callback, which obtains the pair (optimization_state, geoopt_state) and is expected to return false (continue iterating) or true (halt iterations). Note that specifying this overwrites the default printing callback. The calculation thus becomes silent unless a GeoOptDefaultCallback is included in the callback.\nkwargs: All other keyword arguments are passed to the call to solve. Note, that if special kwargs should be passed to the Optimization.OptimizationProblem the user needs to setup the problem manually (e.g. OptimizationProblem(system, calculator))\n\n\n\n\n\n","category":"function"},{"location":"apireference/#GeometryOptimization.update_not_clamped_positions-Tuple{Any, AbstractVector{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}}","page":"API reference","title":"GeometryOptimization.update_not_clamped_positions","text":"update_not_clamped_positions(\n    system,\n    positions::AbstractVector{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}\n) -> AtomsBase.FlexibleSystem{_A, _B, AtomsBase.PeriodicCell{_A1, _B1}} where {_A, _B, _A1, _B1}\n\n\nCreates a new system based on system where the non clamped positions are updated to the ones provided (in the order in which they appear in the system).\n\n\n\n\n\n","category":"method"},{"location":"apireference/#GeometryOptimization.update_positions-Tuple{Any, AbstractVector{<:AbstractVector{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}}}","page":"API reference","title":"GeometryOptimization.update_positions","text":"update_positions(\n    system,\n    positions::AbstractVector{<:AbstractVector{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}}\n) -> AtomsBase.FlexibleSystem{_A, _B, AtomsBase.PeriodicCell{_A1, _B1}} where {_A, _B, _A1, _B1}\n\n\nCreates a new system based on system but with atoms positions updated  to the ones provided.\n\n\n\n\n\n","category":"method"},{"location":"examples/aluminium_dftk/#Aluminium-supercell-using-density-functional-theory","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"","category":"section"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"In this example we will optimise the structure of a rattled aluminium system using density-functional theory.","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"First we build a rattled aluminium system:","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"using AtomsBuilder\nusing Unitful\n\nsystem = rattle!(bulk(:Al; cubic=true), 0.2u\"Å\")","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"Next we create a calculator employing the density-functional toolkit to compute energies and forces at using the LDA density functional. As pseudopotentials we use the PseudoDojo as available in the PseudoPotentialData package.","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"using DFTK\nusing PseudoPotentialData\n\npseudopotentials = PseudoFamily(\"dojo.nc.sr.lda.v0_4_1.oncvpsp3.standard.upf\")\nmodel_kwargs = (; functionals=LDA(), temperature=1e-3, pseudopotentials)\nbasis_kwargs = (; kgrid=(3, 3, 3), Ecut=10.0)\nscf_kwargs   = (; mixing=KerkerMixing())\ncalc = DFTKCalculator(; model_kwargs, basis_kwargs, scf_kwargs)","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"info: Crude computational parameters\nNote, that the numerical parameters above are chosen rather crudely in order to give a fast runtime on CI systems. For production calculations one would require larger computational parameters.","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"We perform the structure optimisation using the LBFGS solver from Optim with solver parameters adapted for our geometry optimisation setting. This is selected by passing the GeometryOptimization.OptimLBFGS solver as the third argument. The verbosity=2 flag makes sure we get output from both the geometry optimisation as well as the inner SCF solver.","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"using GeometryOptimization\nGO = GeometryOptimization\n\nresults = minimize_energy!(system, calc, GO.OptimLBFGS();\n                           tol_forces=1e-4u\"eV/Å\", verbosity=2)\nnothing","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"tip: Automatically adapted calculator parameters\nSome calculators (such as DFTK) are able to adapt to the keyword arguments and parameters passed to minimize_energy!. In this case the SCF tolerance is automatically adapted according to the convergence parameters (here tol_forces) passed to minimize_energy!.","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"The final energy is","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"results.energy","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"We can view the final structure","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"results.system","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"Some statistics about the optimisation","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"results.stats","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"or the details about the selected algorithm:","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"results.alg","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"The final state of the calculator object is also accessible via results.state and could be employed for postprocessing using the framework of the calculator. E.g. in the case of DFTK, the results.state is what DFTK calls an scfres and could just be used to plot a density of states or plot bands or compute response properties.","category":"page"},{"location":"examples/other_solvers/#Using-a-different-Optimization.jl-compatible-solver","page":"Using a different Optimization.jl compatible solver","title":"Using a different Optimization.jl compatible solver","text":"","category":"section"},{"location":"examples/other_solvers/","page":"Using a different Optimization.jl compatible solver","title":"Using a different Optimization.jl compatible solver","text":"In this example we perform the simplistic optimisation the bond length of a Hydrogen molecule using a trust region quasi-Newton method from NLopt.","category":"page"},{"location":"examples/other_solvers/","page":"Using a different Optimization.jl compatible solver","title":"Using a different Optimization.jl compatible solver","text":"We create a calculator employing the density-functional toolkit to compute energies and forces at using the LDA density functional.","category":"page"},{"location":"examples/other_solvers/","page":"Using a different Optimization.jl compatible solver","title":"Using a different Optimization.jl compatible solver","text":"using DFTK\nusing PseudoPotentialData\n\npseudopotentials = PseudoFamily(\"dojo.nc.sr.lda.v0_4_1.oncvpsp3.standard.upf\")\nmodel_kwargs = (; functionals=LDA(), pseudopotentials)\nbasis_kwargs = (; kgrid=(1, 1, 1), Ecut=20.0)\ncalc = DFTKCalculator(; model_kwargs, basis_kwargs)","category":"page"},{"location":"examples/other_solvers/","page":"Using a different Optimization.jl compatible solver","title":"Using a different Optimization.jl compatible solver","text":"and we build the hydrogen molecular system, where we attach pseudopotential information for DFTK:","category":"page"},{"location":"examples/other_solvers/","page":"Using a different Optimization.jl compatible solver","title":"Using a different Optimization.jl compatible solver","text":"using AtomsBuilder\nusing Unitful\nusing UnitfulAtomic\n\nbounding_box = [[10.0, 0.0, 0.0], [0.0, 10.0, 0.0], [0.0, 0.0, 10.0]]u\"Å\"\nsystem = periodic_system([:H => [0, 0, 1.]u\"bohr\",\n                          :H => [0, 0, 3.]u\"bohr\"],\n                         bounding_box)\nnothing","category":"page"},{"location":"examples/other_solvers/","page":"Using a different Optimization.jl compatible solver","title":"Using a different Optimization.jl compatible solver","text":"We now run GeometryOptimization.minimize_energy!, but notably pass the NLopt.LD_TNEWTON solver from NLopt as the third argument to employ this solver. Extra keyword argument to NLopt can be added, e.g. here the maxevel=100, which limits the solver to 100 function evaluations:","category":"page"},{"location":"examples/other_solvers/","page":"Using a different Optimization.jl compatible solver","title":"Using a different Optimization.jl compatible solver","text":"using GeometryOptimization\nusing OptimizationNLopt\nsolver = NLopt.LD_TNEWTON()\n\nresults = minimize_energy!(system, calc, solver;\n                           tol_forces=1e-4u\"eV/Å\", verbosity=1,\n                           maxeval=100)\nnothing","category":"page"},{"location":"examples/other_solvers/","page":"Using a different Optimization.jl compatible solver","title":"Using a different Optimization.jl compatible solver","text":"The final hydrogen bond length is:","category":"page"},{"location":"examples/other_solvers/","page":"Using a different Optimization.jl compatible solver","title":"Using a different Optimization.jl compatible solver","text":"using LinearAlgebra\nnorm(position(results.system[1]) - position(results.system[2]))","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GeometryOptimization","category":"page"},{"location":"#GeometryOptimization","page":"Home","title":"GeometryOptimization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A geometry optimization package for AtomsBase structures and AtomsCalculator calculators. The source code can be found on github.","category":"page"},{"location":"#Motivating-example","page":"Home","title":"Motivating example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We consider the optimisation of the bondlength of a hydrogen molecule using a simple Lennard Jones potential:","category":"page"},{"location":"","page":"Home","title":"Home","text":"## TODO: Should run as @example once EmpiricalPotentials is compatible\nusing AtomsBase\nusing EmpiricalPotentials\nusing GeometryOptimization\nusing Unitful\nusing UnitfulAtomic\n\n# Setup system and calculator\nsystem = isolated_system([:H => [0, 0, 0.0]u\"bohr\",\n                          :H => [0, 0, 1.9]u\"bohr\"])\ncalc = LennardJones(-1.17u\"hartree\", 0.743u\"angstrom\", 1, 1, 0.6u\"nm\")\n\n# Run the geometry optimisation (using verbosity=1 to print the progress)\nresults = minimize_energy!(system, calc; verbosity=1)\n\n# Inspect the results\noptimised_system = results.system\noptimised_bondlength = norm(position(optsystem[1]) - position(optsystem[2]))","category":"page"},{"location":"","page":"Home","title":"Home","text":"The idea is that any AtomsBase-compatible structure can be employed as a system any AtomsCalculators-compatible calculator as a calc. See the list of examples to get an overview of possible calculators to employ.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that minimize_energy! supports further arguments to fine-tune the convergence tolerance or customise the solver selection. See the API documentation or the examples to explore this.","category":"page"},{"location":"examples/tial_lj/#TiAl-structure-optimisation","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"","category":"section"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"TODO Write some text motivating this example","category":"page"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"Setup system:","category":"page"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"## TODO: Should run as @example once EmpiricalPotentials is compatible with AB 0.5\nusing AtomsIO\nusing EmpiricalPotentials\n\nsystem = load_system(joinpath(pkgdir(EmpiricalPotentials), \"data/TiAl-1024.xyz\"))\nnothing","category":"page"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"Setup calculator:","category":"page"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"## TODO: Should run as @example once EmpiricalPotentials is compatible with AB 0.5\nusing Unitful\nusing UnitfulAtomic\n\ncalc = LennardJones(-1.0u\"meV\", 3.1u\"Å\", 13, 13, 6.0u\"Å\")\nnothing","category":"page"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"Minimise energy:","category":"page"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"## TODO: Should run as @example once EmpiricalPotentials is compatible with AB 0.5\nusing GeometryOptimization\nGO = GeometryOptimization\n\nresults = minimize_energy!(system, calc, GO.OptimCG(); maxiters=10, verbosity=1)\nresults.energy","category":"page"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"Final structure:","category":"page"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"## TODO: Should run as @example once EmpiricalPotentials is compatible with AB 0.5\n\nresults.system","category":"page"}]
}
