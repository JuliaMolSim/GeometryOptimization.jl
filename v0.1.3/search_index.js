var documenterSearchIndex = {"docs":
[{"location":"examples/variablecell/#Silicon-variable-cell-relaxation","page":"Silicon variable cell relaxation","title":"Silicon variable cell relaxation","text":"","category":"section"},{"location":"examples/variablecell/","page":"Silicon variable cell relaxation","title":"Silicon variable cell relaxation","text":"In this example we optimise both atomic positions and lattice geometry of a rattled silicon structure using a Stillinger-Weber potential.","category":"page"},{"location":"examples/variablecell/","page":"Silicon variable cell relaxation","title":"Silicon variable cell relaxation","text":"We build an initial structure by first rattling the positions and than the lattice geometry:","category":"page"},{"location":"examples/variablecell/","page":"Silicon variable cell relaxation","title":"Silicon variable cell relaxation","text":"using AtomsBase\nusing AtomsBuilder\nusing LinearAlgebra\nusing Unitful\nusing UnitfulAtomic\n\nsilicon_posrattle = rattle!(bulk(:Si, cubic=true) * (2, 2, 2), 0.1u\"Ã…\")\nF = I + 1e-3randn(3, 3)\nnew_cell_vectors = tuple([F * v for v in cell_vectors(silicon_posrattle)]...)\nsilicon_rattle = AbstractSystem(silicon_posrattle; cell_vectors=new_cell_vectors)","category":"page"},{"location":"examples/variablecell/","page":"Silicon variable cell relaxation","title":"Silicon variable cell relaxation","text":"and optimise with variablecell=true","category":"page"},{"location":"examples/variablecell/","page":"Silicon variable cell relaxation","title":"Silicon variable cell relaxation","text":"using EmpiricalPotentials\nusing GeometryOptimization\n\nsw = StillingerWeber()\nsilicon = minimize_energy!(silicon_posrattle, sw;\n                           variablecell=true, verbosity=1, tol_virial=1e-4u\"hartree\").system\nnothing  # hide","category":"page"},{"location":"examples/variablecell/","page":"Silicon variable cell relaxation","title":"Silicon variable cell relaxation","text":"Final structure:","category":"page"},{"location":"examples/variablecell/","page":"Silicon variable cell relaxation","title":"Silicon variable cell relaxation","text":"silicon","category":"page"},{"location":"apireference/","page":"API reference","title":"API reference","text":"CurrentModule = GeometryOptimization","category":"page"},{"location":"apireference/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"apireference/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"apireference/","page":"API reference","title":"API reference","text":"Modules = [GeometryOptimization]","category":"page"},{"location":"apireference/#GeometryOptimization.Autoselect","page":"API reference","title":"GeometryOptimization.Autoselect","text":"Use a heuristic to automatically select the minimisation algorithm (Currently OptimCG, but this may change silently)\n\n\n\n\n\n","category":"type"},{"location":"apireference/#GeometryOptimization.DofManager","page":"API reference","title":"GeometryOptimization.DofManager","text":"DofManager:\n\nConstructor:\n\nDofManager(sys; variablecell = false, r0 =..., free=..., clamp=..., mask=...)\n\nvariablecell determines whether the cell is fixed or allowed to change during optimization\nr0 is a reference length-scale, default set to one (in the unit of sys),  this is used to non-dimensionalize the degrees of freedom.\n\nIn addition set at most one of the kwargs:\n\nno kwarg: all atoms are free\nfree : list of free atom indices (not dof indices)\nclamp : list of clamped atom indices (not dof indices)\nmask : 3 x N Bool array to specify individual coordinates to be clamped\n\nMeaning of dofs\n\nOn call to the constructor, DofManager stores positions and cell X0, C0, dofs are understood relative to this initial configuration. get_dofs(sys, dm::DofManager) returns a vector that represents the non-dimensional displacement and a deformation matrix (U, F). The new configuration extracted from a dof vector is understood as\n\nThe new cell: C = F * C0\nThe new positions: ð«[i] = F * (X0[i] + U[i] * r0)\n\nOne aspect of this definition is that clamped atom positions still change via the deformation F. This is natural in the context of optimizing the cell shape.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#GeometryOptimization.GeoOptDefaultCallback","page":"API reference","title":"GeometryOptimization.GeoOptDefaultCallback","text":"Callback producing a convergence table summarising the geometry optimisation convergence. If always_show_header=true the header is shown in each iteration. This is helpful if the calculator produces output as well.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#GeometryOptimization.GeoOptProblem","page":"API reference","title":"GeometryOptimization.GeoOptProblem","text":"GeoOptProblem(system, calculator, dofmgr, geoopt_state; kwargs...)\n\nTurn system, calculator and geoopt_state::GeometryOptimizationState into an OptimizationProblem for solve_problem. Note that the system is not updated automatically and that internally atomic units are used.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#GeometryOptimization.OptimCG","page":"API reference","title":"GeometryOptimization.OptimCG","text":"Use Optim's ConjugateGradient implementation with some good defaults.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#GeometryOptimization.OptimLBFGS","page":"API reference","title":"GeometryOptimization.OptimLBFGS","text":"Use Optim's LBFGS implementation with some good defaults.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#GeometryOptimization.OptimSD","page":"API reference","title":"GeometryOptimization.OptimSD","text":"Use Optim's GradientDescent (Steepest Descent) implementation with some good defaults.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#GeometryOptimization.analyze_mask-NTuple{4, Any}","page":"API reference","title":"GeometryOptimization.analyze_mask","text":"analyze_mask(sys, free, clamp, mask) -> Any\n\n\nanalyze_mask : helper function to generate list of dof indices from lists of atom indices indicating free and clamped atoms\n\n\n\n\n\n","category":"method"},{"location":"apireference/#GeometryOptimization.clamp_atoms-Tuple{Any, Union{Nothing, AbstractVector{<:Integer}}}","page":"API reference","title":"GeometryOptimization.clamp_atoms","text":"clamp_atoms(\n    system,\n    clamped_indexes::Union{Nothing, AbstractVector{<:Integer}}\n) -> AtomsBase.FlexibleSystem{_A, _B, AtomsBase.PeriodicCell{_A1, _B1}} where {_A, _B, _A1, _B1}\n\n\nClamp given atoms in the system. Clamped atoms are fixed and their positions will not be optimized. The atoms to be clamped should be given as a list of indices corresponding to their positions in the system.\n\nwarn: Experimental\nThis is this a very experimental interface and will likely change in the future.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#GeometryOptimization.convert_to_updatable-Tuple{Any}","page":"API reference","title":"GeometryOptimization.convert_to_updatable","text":"convert_to_updatable(system) -> Any\n\n\nConvert the input system to a kind of system we can work with, i.e. one where we have the particles keyword argument for setting new particles and positions.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#GeometryOptimization.minimize_energy!","page":"API reference","title":"GeometryOptimization.minimize_energy!","text":"minimize_energy!(system, calculator; ...)\nminimize_energy!(system, calculator, solver; kwargs...)\n\n\nMinimise the energy of a system using the specified calculator. Optimises either only atomic positions (variablecell=false) or both positions and lattice (variablecell=true). Returns a named tuple including the optimised system as first entry. Typical arguments passed as solver are Autoselect() (the default), OptimLBFGS(), OptimCG(), OptimSD(). These automatically choose some heuristics for setting up the solvers, which we found to work well in practice.\n\nBeyond that any other first-order solver compatible with Optimization.jl can also be employed. Note, that in principle all such solvers should work, but we only tested a small fraction and you can expect that minor modifications are needed to make some solvers work (PRs appreciated!). In general only first-order or second-order methods work.\n\nSee GeometryOptimization.clamp_atoms for an experimental way how to clamp atoms.\n\nKeyword arguments:\n\nvariablecell: Determines whether the cell is fixed or allowed to change during optimization\nmaxiters: Maximal number of iterations\nmaxtime:  Maximal allowed runtime (in seconds)\ntol_energy: Tolerance in the energy to stop the minimisation (all tol_* need to be satisfied)\ntol_forces:  Tolerance in the force  to stop the minimisation (all tol_* need to be satisfied)\ntol_virial: Tolerance in the virial to stop the minimisation (all tol_* need to be satisfied)\nmaxstep: Maximal step size (in AU or length units) to be taken in a single optimisation step (not supported for all solvers)\nverbosity: Printing level. The idea is that 0 is silent, 1 displays the optimisation progress and â‰¥ 2 starts displaying things from the calculator as well (e.g SCF iterations).\ncallback: A custom callback, which obtains the pair (optimization_state, geoopt_state) and is expected to return false (continue iterating) or true (halt iterations). Note that specifying this overwrites the default printing callback. The calculation thus becomes silent unless a GeoOptDefaultCallback is included in the callback.\nkwargs: All other keyword arguments are passed to the call to solve. Note, that if special kwargs should be passed to the Optimization.OptimizationProblem the user needs to setup the problem manually (e.g. OptimizationProblem(system, calculator))\n\n\n\n\n\n","category":"function"},{"location":"examples/aluminium_dftk/#Aluminium-supercell-using-density-functional-theory","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"","category":"section"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"In this example we will optimise the structure of a rattled aluminium system using density-functional theory.","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"First we build a rattled aluminium system:","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"using AtomsBuilder\nusing Unitful\n\nsystem = rattle!(bulk(:Al; cubic=true), 0.2u\"Ã…\")","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"Next we create a calculator employing the density-functional toolkit to compute energies and forces at using the LDA density functional. As pseudopotentials we use the PseudoDojo as available in the PseudoPotentialData package.","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"using DFTK\nusing PseudoPotentialData\n\npseudopotentials = PseudoFamily(\"dojo.nc.sr.lda.v0_4_1.oncvpsp3.standard.upf\")\nmodel_kwargs = (; functionals=LDA(), temperature=1e-3, pseudopotentials)\nbasis_kwargs = (; kgrid=(3, 3, 3), Ecut=10.0)\nscf_kwargs   = (; mixing=KerkerMixing())\ncalc = DFTKCalculator(; model_kwargs, basis_kwargs, scf_kwargs)","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"info: Crude computational parameters\nNote, that the numerical parameters above are chosen rather crudely in order to give a fast runtime on CI systems. For production calculations one would require larger computational parameters.","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"We perform the structure optimisation using the LBFGS solver from Optim with solver parameters adapted for our geometry optimisation setting. This is selected by passing the OptimLBFGS solver as the third argument. The verbosity=2 flag makes sure we get output from both the geometry optimisation as well as the inner SCF solver.","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"using GeometryOptimization\n\nresults = minimize_energy!(system, calc, OptimLBFGS();\n                           tol_forces=1e-4u\"eV/Ã…\", verbosity=2)\nnothing","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"tip: Automatically adapted calculator parameters\nSome calculators (such as DFTK) are able to adapt to the keyword arguments and parameters passed to minimize_energy!. In this case the SCF tolerance is automatically adapted according to the convergence parameters (here tol_forces) passed to minimize_energy!.","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"The final energy is","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"results.energy","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"We can view the final structure","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"results.system","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"The results object returned from Optim (containing some statistics about the optimisation):","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"results.optimres","category":"page"},{"location":"examples/aluminium_dftk/","page":"Aluminium supercell using density-functional theory","title":"Aluminium supercell using density-functional theory","text":"The final state of the calculator object is also accessible via results.state and could be employed for postprocessing using the framework of the calculator. E.g. in the case of DFTK, the results.state is what DFTK calls an scfres and could just be used to plot a density of states or plot bands or compute response properties.","category":"page"},{"location":"examples/other_solvers/#Using-a-Optimization.jl-compatible-solver","page":"Using a Optimization.jl compatible solver","title":"Using a Optimization.jl compatible solver","text":"","category":"section"},{"location":"examples/other_solvers/","page":"Using a Optimization.jl compatible solver","title":"Using a Optimization.jl compatible solver","text":"In this example we optimize a bulk silicon structure using a trust region quasi-Newton method from NLopt.","category":"page"},{"location":"examples/other_solvers/","page":"Using a Optimization.jl compatible solver","title":"Using a Optimization.jl compatible solver","text":"We create a Stillinger-Weber calculator","category":"page"},{"location":"examples/other_solvers/","page":"Using a Optimization.jl compatible solver","title":"Using a Optimization.jl compatible solver","text":"using EmpiricalPotentials\nsw = StillingerWeber()\nnothing","category":"page"},{"location":"examples/other_solvers/","page":"Using a Optimization.jl compatible solver","title":"Using a Optimization.jl compatible solver","text":"and we build a slightly rattled silicon structure","category":"page"},{"location":"examples/other_solvers/","page":"Using a Optimization.jl compatible solver","title":"Using a Optimization.jl compatible solver","text":"using AtomsBuilder\nusing Unitful\nsystem = rattle!(bulk(:Si, cubic=true) * (2, 2, 2), 0.1u\"Ã…\")","category":"page"},{"location":"examples/other_solvers/","page":"Using a Optimization.jl compatible solver","title":"Using a Optimization.jl compatible solver","text":"We now run GeometryOptimization.minimize_energy!, but notably pass the NLopt.LD_TNEWTON solver from NLopt as the third argument to employ this solver. Extra keyword argument to NLopt can be added, e.g. here the maxevel=100, which limits the solver to 100 function evaluations:","category":"page"},{"location":"examples/other_solvers/","page":"Using a Optimization.jl compatible solver","title":"Using a Optimization.jl compatible solver","text":"using GeometryOptimization\nusing OptimizationNLopt\nsolver = NLopt.LD_TNEWTON()\n\nresults = minimize_energy!(system, sw, solver;\n                           tol_forces=1e-4u\"eV/Ã…\", verbosity=1,\n                           maxeval=100)\nnothing","category":"page"},{"location":"examples/other_solvers/","page":"Using a Optimization.jl compatible solver","title":"Using a Optimization.jl compatible solver","text":"info: \nWhile in principle all first-order solvers supported by Optimization.jl can be employed, only few have been tested with this package so far. Given the complexity of the Optimization.jl ecosystem we expect that minor changes of our integration may be needed to make specific solvers work well. We welcome any PRs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GeometryOptimization","category":"page"},{"location":"#GeometryOptimization","page":"Home","title":"GeometryOptimization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A geometry optimization package for AtomsBase structures and AtomsCalculator calculators. The source code can be found on github.","category":"page"},{"location":"#Motivating-example","page":"Home","title":"Motivating example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We consider the optimisation of the bondlength of a hydrogen molecule using a simple Lennard Jones potential:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using AtomsBase\nusing EmpiricalPotentials\nusing GeometryOptimization\nusing LinearAlgebra\nusing Unitful\nusing UnitfulAtomic\n\n# Setup system and calculator\ncell_vectors = ([10.0, 0.0, 0.0]u\"Ã…\", [0.0, 10.0, 0.0]u\"Ã…\", [0.0, 0.0, 10.0]u\"Ã…\")\nsystem = periodic_system([:H => [0, 0, 0.0]u\"bohr\",\n                          :H => [0, 0, 1.9]u\"bohr\"],\n                         cell_vectors)\nzH = 1\nemins = Dict((zH, zH) => -1.17u\"hartree\", )\nrmins = Dict((zH, zH) =>  0.743u\"Ã…\",      )\ncalc = LennardJones(emins, rmins, 5.0u\"Ã…\")\n\n# Run the geometry optimisation (using verbosity=1 to print the progress)\nresults = minimize_energy!(system, calc; verbosity=1)\n\n# Inspect the results\noptsystem = results.system\noptimised_bondlength = norm(position(optsystem[1]) - position(optsystem[2]))\nnothing  # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"The idea is that any AtomsBase-compatible structure can be employed as a system any AtomsCalculators-compatible calculator as a calc. See the list of examples to get an overview of possible calculators to employ.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that minimize_energy! supports further arguments to fine-tune the convergence tolerance or customise the solver selection. See the API documentation or the examples to explore this.","category":"page"},{"location":"examples/tial_lj/#TiAl-structure-optimisation","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"","category":"section"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"TODO Write some text motivating this example","category":"page"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"Setup system:","category":"page"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"using AtomsIO\nusing EmpiricalPotentials\n\nsystem = load_system(joinpath(pkgdir(EmpiricalPotentials), \"data/TiAl-1024.xyz\"))\nnothing  # hide","category":"page"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"Setup calculator:","category":"page"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"using Unitful\nusing UnitfulAtomic\n\n# Note: These are completely made up parameters,\n#       please do not use in production\nrcut = 5.0u\"Ã…\"\nzAl = atomic_number(ChemicalSpecies(:Al))\nzTi = atomic_number(ChemicalSpecies(:Ti))\nemins = Dict( (zAl, zAl) => -1.0u\"eV\",\n              (zAl, zTi) => -1.234u\"eV\",\n              (zTi, zTi) => -0.345u\"eV\" )\nrmins = Dict( (zAl, zAl) => 2.7u\"Ã…\",\n              (zAl, zTi) => 3.2u\"Ã…\",\n              (zTi, zTi) => 3.0u\"Ã…\" )\ncalc = LennardJones(emins, rmins, rcut)\nnothing  # hide","category":"page"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"Minimise energy:","category":"page"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"using GeometryOptimization\n\nresults = minimize_energy!(system, calc, OptimCG(); maxiters=10, verbosity=1)\nnothing  # hide","category":"page"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"Final structure:","category":"page"},{"location":"examples/tial_lj/","page":"TiAl structure optimisation","title":"TiAl structure optimisation","text":"results.system","category":"page"}]
}
